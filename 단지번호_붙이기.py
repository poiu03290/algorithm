# 단지 번호 붙이기(DFS, BFS)
# 그림1과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다.
# 철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 
# 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 
# 대각선상에 집이 있는 경우는 연결된 것이 아니다.
# 그림2는 그림1을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 
# 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.

# 0 1 1 0 1 0 0
# 0 1 1 0 1 0 1
# 1 1 1 0 1 0 1
# 0 0 0 0 1 1 1
# 0 1 0 0 0 0 0
# 0 1 1 1 1 1 0
# 0 1 1 1 0 0 0
#  [그림 1] 

# 0 1 1 0 2 0 0
# 0 1 1 0 2 0 2
# 1 1 1 0 2 0 2
# 0 0 0 0 2 2 2
# 0 3 0 0 0 0 0
# 0 3 3 3 3 3 0
# 0 3 3 3 0 0 0
#  [그림 2]

# ▣ 입력설명
# 첫 번째줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고 
# 그 다음 N줄에는 각각 N개의 자료(0 혹은 1)가 입력된다.

# ▣ 출력설명
# 첫 번째줄에는 총 단지수를 출력하시오. 그리고 각 단지내의 집의 수를 오름차순으로 정렬하여 한줄에 하나씩 출력하시오.

# ▣ 입력예제 1 
# 7
# 0110100
# 0110101
# 1110101
# 0000111
# 0100000
# 0111110
# 0111000

# ▣ 출력예제 1
# 3
# 7
# 8
# 9

# 출처 : 한국정보올림피아드

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def DFS(x, y):
    global cnt
    cnt += 1  # 집찾았으니 DFS돌자마자 바로 cnt += 1
    board[x][y] = 0   # 찾은 지점 0으로 변경(다시 back할때 또 세면 안되니까)
    for i in range(4):
        xx = x + dx[i]
        yy = y + dy[i]
        if 0 <= xx < n and 0 <= yy < n and board[xx][yy] == 1:
            DFS(xx, yy)

if __name__ == "__main__":
    n = int(input())
    board = [list(map(int, input())) for _ in range(n)]  # 입력이 띄어쓰기로 안되어있기 때문에 split()사용 x
    res = []
    for i in range(n):
        for j in range(n):  # 2차원 리스트니까 2중for문
            if board[i][j] == 1:  # 2중for문 돌면서 1발견(집발견)
                cnt = 0
                DFS(i, j)  # i와 j지점부터 DFS 시작!
                res.append(cnt)
    print(len(res))
    res.sort()
    for i in res:
        print(i)