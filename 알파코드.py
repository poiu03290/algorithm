# 알파코드(DFS)
# 철수와 영희는 서로의 비밀편지를 암호화해서 서로 주고받기로 했다. 그래서 서로 어떻게 암호화를 할 것인지 의논을 하고 있다.
# 영희 : 우리 알파벳 A에는 1로, B에는 2로 이렇게 해서 Z에는 26을 할당하여 번호로 보내기로 하자.
# 철수 : 정말 바보같은 생각이군!! 생각해 봐!! 만약 내가 “BEAN"을 너에게 보낸다면 그것을 암호화하면 25114이잖아!! 
# 그러면 이것을 다시 알파벳으로 복원할 때는 많은 방법이 존재하는 데 어떻게 할건데... 
# 이것을 알파벳으로 바꾸면 BEAAD, YAAD, YAN, YKD 그리고 BEKD로 BEAN말고도 5가지나 더 있군.
# 당신은 위와 같은 영희의 방법으로 암호화된 코드가 주어지면 그것을 알파벳으로 복원하는데 얼마나 많은 방법인 있는지 구하세요.

# ▣ 입력설명
# 첫 번째 줄에 숫자로 암호화된 코드가 입력된다. (코드는 0으로 시작하지는 않는다, 코드의 길이는 최대 50이다) 
# 0이 입력되면 입력종료를 의미한다.

# ▣ 출력설명
# 입력된 코드를 알파벳으로 복원하는데 몇 가지의 방법이 있는지 각 경우를 출력한다. 그 가지수도 출력한다. 
# 단어의 출력은 사전순으로 출력한다.

# ▣ 입력예제 1 
# 25114

# ▣ 출력예제 1
# BEAAD
# BEAN
# BEKD
# YAAD
# YAN
# YKD
# 6

def DFS(L, P):
    global cnt
    if L == n:
        cnt += 1
        for j in range(P):
            print(chr(res[j]+64), end='')  # res엔 현재 숫자만 들어가있는데 이걸 chr()문법을 통해 알파벳으로 바꾸고 대문자변환을 위해 +64를 해줌. 
    else:
        for i in range(1, 27):   # 알파벳의 개수인 26까지 for문이 돌고 이때 i가 한자리일수도, 두자리일수 있음.
            if code[L] == i:   # 이때 i가 한자리(ex: 2)에 매칭되면 
                res[P] = i  # 그리고 res에 그 한자리인 i를 넣음
                DFS(L+1, P+1)     # L은 +1
            elif i >= 10 and code[L] == i//10 and code[L+1] == i % 10:  # i가 두자리(ex: 21)에 매칭되면
                res[P] = i   # 그리고 res에 그 두자리인 i를 넣음
                DFS(L+2, P+1)  # L은 +2

if __name__ == "__main__":
    code = list(map(int, input()))   # 리스트로 보관해.
    n = len(code)
    code.insert(n, -1)   # for문을 통해 각 숫자에 반복문을 돌리는데 이떄 한자리, 두자리 돌린다. 근데 마지막글자 반복문돌릴때 두자리는 확인하지 못하니까 out of index가 나옴. 그래서 마지막에 인위적으로 숫자 하나를 넣어준거임.
    res = [0] * (n+3)
    cnt = 0
    DFS(0, 0)