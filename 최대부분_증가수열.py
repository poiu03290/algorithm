# 최대 부분 증가수열
# N개의 자연수로 이루어진 수열이 주어졌을 때, 그 중에서 가장 길게 증가하는(작은 수에서 큰 수로) 원소들의 집합을 찾는 프로그램을 작성하라. 
# 예를 들어, 원소가 2, 7, 5, 8, 6, 4, 7, 12, 3 이면 가장 길게 증가하도록 원소들을 차례대로 뽑아내면 
# 2, 5, 6, 7, 12를 뽑아내어 길이가 5인 최대 부분 증가수열을 만들 수 있다.

# ▣ 입력설명
# 첫째 줄은 입력되는 데이터의 수 N(2≤N≤1,000, 자연수)를 의미하고, 
# 둘째 줄은 N개의 입력데이터들이 주어진다. 

# ▣ 출력설명
# 첫 번째 줄에 부분증가수열의 최대 길이를 출력한다.

# ▣ 입력예제 1 
# 8
# 5 3 7 8 6 2 9 4

# ▣ 출력예제 1
# 4

# 마지막항에 넣을 값을 하나씩 대입. 두번째숫자인 3을 마지막항에 넣는다고 가정하면 증가수열의 길이는 1이다. 앞서 온값인 5보다 작기때문.
# 다음값인 7은 5-7, 3-7로 길이는 2. 그다음값인 8은 5-7-8, 3-7-8로 길이는 3.
# 여기서 한가지 주목할점은 8은 앞 7 보다 큰숫자이며, 7의 길이보다 자신을더해줌으로써 길이가 + 1이 된다.
# 또 다음 값인 6이라면, 7과 8보다 작은숫자이기때문에 5-6, 3-6으로 길이가 2. 
# 즉, 마지막에 넣을 값이 앞선숫자보다 커야하며, 그 숫자의 길이에 +1을 해주면 된다.

import sys
n = int(input())
arr = list(map(int, input().split()))
dy = [0] * (n+1)
arr.insert(0, 0)   # 인덱스 숫자 맞추기위해 0 삽입.
dy[1] = 1  # 첫번째 증가수열의 길이는 첫번째니까 하나겠지.
res = 0

for i in range(2, n+1):   # 두번째부터 n번까지 돎
    max = 0
    for j in range(i-1, 0, -1):   # 
        if arr[j] < arr[i] and max < dy[j]:   # arr[j] < arr[i]는 내가 마지막항에 넣을 값보다 작아야한다는뜻.
            max = dy[j]   # max에 dy[j]값을 넣어줌으로써 최댓값을 계속 갱신. 
    dy[i] = max + 1   # 최댓값에 +1을 해줌
    if res < dy[i]:
        res = dy[i]

print(res)  